Perfect. Then we do this cleanly and explicitly for Claude.

Below is a copy-paste instruction you can send to Claude.
It is scoped, unambiguous, and prevents ‚Äúcreative fixes‚Äù.

‚∏ª

üì© MESSAGE TO CLAUDE ‚Äî Instrumentation only, no fixes

Context

We have confirmed that all environments are in sync (GitHub main, Mac, Replit, iOS simulator).
The app runs correctly on web, but crashes on iOS when swiping an Echo card from bottom-right ‚Üí top-left.

The crash stack shows a Hermes/Reanimated abort during a gesture event.

Your task is NOT to fix anything yet.
Your only task is to instrument the gesture layer so the crash explains itself.

‚∏ª

RULES (important)
	1.	‚ùå Do NOT change gesture logic, thresholds, math, directions, or conditions
	2.	‚ùå Do NOT refactor components
	3.	‚ùå Do NOT add guards ‚Äújust in case‚Äù
	4.	‚ùå Do NOT remove or rewrite existing handlers
	5.	‚úÖ ONLY add debug flags and logging
	6.	‚úÖ All instrumentation must be safe for Reanimated (use runOnJS)

‚∏ª

Step 1 ‚Äî Global debug flag

Create or edit:

lib/debug.ts

export const DEBUG_GESTURES = true;

This flag must be imported wherever gesture instrumentation is added.

‚∏ª

Step 2 ‚Äî Gesture logging helper

In the file where Echo card swipe gestures are defined, add:

import { DEBUG_GESTURES } from '@/lib/debug';
import { runOnJS } from 'react-native-reanimated';

const gestureDebug = (...args: any[]) => {
  console.log('[GESTURE]', ...args);
};


‚∏ª

Step 3 ‚Äî Instrument ALL gesture lifecycle phases

For the gesture that handles Echo card swiping, add logging to:

onBegin

onBegin: () => {
  if (DEBUG_GESTURES) {
    runOnJS(gestureDebug)('BEGIN');
  }
},

onUpdate

onUpdate: (e) => {
  if (DEBUG_GESTURES) {
    runOnJS(gestureDebug)('UPDATE', {
      translationX: e.translationX,
      translationY: e.translationY,
      velocityX: e.velocityX,
      velocityY: e.velocityY,
      absoluteX: e.absoluteX,
      absoluteY: e.absoluteY,
    });
  }
},

onEnd

onEnd: () => {
  if (DEBUG_GESTURES) {
    runOnJS(gestureDebug)('END');
  }
},

onFinalize (if present)

onFinalize: () => {
  if (DEBUG_GESTURES) {
    runOnJS(gestureDebug)('FINALIZE');
  }
},


‚∏ª

Step 4 ‚Äî No silent failures

If any of the following exist in the gesture code:
	‚Ä¢	Derived values
	‚Ä¢	Math on translation or velocity
	‚Ä¢	Direction inference
	‚Ä¢	Threshold comparisons

Add read-only logging immediately before they are used:

runOnJS(gestureDebug)('DERIVED', { valueName, value });

‚ö†Ô∏è Do NOT guard or change behavior ‚Äî only observe.

‚∏ª

Step 5 ‚Äî Output expectations

After your changes, swiping bottom-right ‚Üí top-left on iOS must produce logs like:

[GESTURE] BEGIN
[GESTURE] UPDATE { ... }
[GESTURE] UPDATE { ... }
[GESTURE] UPDATE { ... }

The crash should occur between two known logs, or before a missing phase.

That gap is what we will analyze next.

‚∏ª

Deliverable
	‚Ä¢	A clean commit with only instrumentation changes
	‚Ä¢	No functional changes
	‚Ä¢	No behavioral fixes

If you are unsure whether something is instrumentation or a fix, do not change it.

‚∏ª

Acknowledge when instrumentation is complete and pushed.

‚∏ª

What happens next (for you)

Once Claude delivers this:
	1.	You pull
	2.	Run once on iOS
	3.	Swipe until crash
	4.	Paste the last [GESTURE] logs printed

At that point the problem collapses from ‚ÄúWTF‚Äù to one broken invariant.

You‚Äôre now doing this the right way.